# -*- coding: utf-8 -*-
"""BEST_time_to_buy_YT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xr_18PesSBV5DpRPVKibO5Ta6o4lpo-y

# BEST TIME TO BUY YT **V5**


[Author's Twitter](https://twitter.com/quant_sheep?t=KqHtg0lNFy-sejP_dFOUXg&s=09)


**buy me a coffee: 0x334D7763eD1e23bD4052e9551DB3Dac506a64F1E**

No coding skills? No problem! I've open-sourced & simplified the analysis: **just fill a form & click in Colab**. Discover the best strategy for earning points with Pendle's YT on your own!

# Risk Warning
1. abcETH's de-pegging risk and underlying asset price risk: The red line represents the amount of points obtained by investing 1 abcETH (not the underlying asset) to purchase YT at a certain point in time and holding it until maturity. The points obtained depend on the pool corresponding to abcETH (such as ezETH), but abcETH may de-peg from ETH. The underlying asset (such as ETH) also has price risk.

2. Strategy risk: The fair implied APY of the strategy is determined based on historical data, so the fair price line cannot be considered an accurate prediction of future prices. The YT Fair price line is a rough estimate of the average YT price based on historical data.

3. Analysis tool risk: The data obtained by analysis tools may not be timely enough. The tools are only for learning and reference, and their stability in a production environment is not guaranteed.

# æœ€ä½³æ—¶æœºè´­ä¹°YTç­–ç•¥ **ç¬¬äº”ç‰ˆæœ¬**

[ä½œè€…çš„æ¨ç‰¹è´¦å·](https://twitter.com/quant_sheep?t=KqHtg0lNFy-sejP_dFOUXg&s=09)

**å¦‚æœä½ è§‰å¾—è¿™ä¸ªå·¥å…·å€¼å¾—ä¸€æ¯å’–å•¡çš„è¯ï¼Œæ¬¢è¿è½¬è´¦æ”¯æŒï¼š0x334D7763eD1e23bD4052e9551DB3Dac506a64F1E**


æ²¡æœ‰ç¼–ç¨‹æŠ€èƒ½ï¼Ÿæ²¡é—®é¢˜ï¼æˆ‘å·²ç»å¼€æºå¹¶ç®€åŒ–äº†åˆ†æï¼š**åªéœ€å¡«å†™è¡¨æ ¼å¹¶åœ¨ Colab ä¸Šç‚¹å‡»**ã€‚ç°åœ¨ï¼Œæ‚¨å¯ä»¥è‡ªå·±å‘ç°ç”¨ Pendle çš„ YT èµšå–ç§¯åˆ†çš„æœ€ä½³ç­–ç•¥ï¼


# é£é™©æç¤º

1. abcETHä¸ETHçš„è„±é”šé£é™©å’Œunderlying assetå¸ä»·é£é™©ï¼šå®é™…ä¸Š çº¢è‰²çš„çº¿ä»£è¡¨ï¼šåœ¨æŸä¸ªæ—¶é—´ç‚¹ï¼ŒæŠ•å…¥ 1 ä¸ªabcETH ï¼ˆè€Œä¸æ˜¯underlyingï¼‰è´­ä¹°ytï¼ŒæŒæœ‰åˆ°æœŸè·å¾—çš„ç§¯åˆ†æ•°é‡ã€‚æ‰€è°“çš„ç§¯åˆ†æ•°é‡æ˜¯ä¾æ®æ± å­å¯¹åº”çš„abcETHï¼ˆæ¯”å¦‚ezETHï¼‰æ‰€å†³å®šçš„ï¼Œä½†æ˜¯abcETHä¼šä¸ETHå‘ç”Ÿè„±é”šï¼ˆdepegï¼‰ã€‚underlying assetï¼ˆå¦‚ETHï¼‰æœ¬èº«ä¹Ÿæœ‰å¸ä»·é£é™©ã€‚

2. ç­–ç•¥é£é™©ï¼šç­–ç•¥çš„fair implied apyæ˜¯ä¾æ®å†å²æ•°æ®å»ç¡®å®šçš„ï¼Œå› æ­¤fair price lineä¸èƒ½çœ‹åšå¯¹æœªæ¥ä»·æ ¼çš„ç²¾å‡†é¢„æµ‹ã€‚YT Fair price lineæ˜¯ä¸€ç§åŸºäºå†å²æ•°æ®å¯¹YT ä»·æ ¼å¹³å‡æ°´å¹³çš„ç²—ç•¥ä¼°è®¡ã€‚

3. åˆ†æå·¥å…·é£é™©ï¼šåˆ†æå·¥å…·è·å–çš„æ•°æ®å¯èƒ½ä¸å¤ŸåŠæ—¶ã€‚å·¥å…·æœ¬èº«åªæ˜¯ä¾›å­¦ä¹ å‚è€ƒï¼Œåœ¨ç”Ÿäº§ç¯å¢ƒä¸­çš„ç¨³å®šæ€§æ²¡æœ‰ä¿éšœã€‚

# ä¸­æ–‡æ•™ç¨‹

[ç­–ç•¥çš„æ›´å¤šä¿¡æ¯](https://docs.google.com/document/d/17CrXT0NUsDGG4QVpROrauR-nTfNzYCVSebtQdiDEgoI/edit)

æ¬¢è¿åŠ å…¥Pendleä¸­æ–‡ç¤¾åŒºè·å–æ›´å¤šç­–ç•¥è®¯æ¯ï¼š[telegramé“¾æ¥](https://t.me/PendleFinance_CN)

ç¬¬0æ­¥éª¤ï¼šé€‰æ‹©æ± å­æ‰€åœ¨çš„çš„ç½‘ç»œï¼ˆç›®å‰æ”¯æŒethereumï¼Œarbitrumï¼Œmantleï¼‰

ç¬¬ä¸€æ­¥ï¼šæ‰“å¼€æ± å­ä¸»é¡µå¡«å…¥Marketå’Œytçš„åˆçº¦åœ°å€:

è¯·æ‰¾åˆ°ä»£å¸ä¸»é¡µï¼Œç‚¹å‡»çº¢è‰²æ–¹æ¡†

å‚è§ç¬¬ä¸€å¼ å›¾ç‰‡

æ¥ä¸‹æ¥æ˜¯å¡«å…¥å¯¹åº”åœ°å€

å‚è§ç¬¬äºŒå¼ å›¾ç‰‡



ç¬¬ä¸‰æ­¥: ç¡®å®šæ¯å°æ—¶å¯è·å¾—çš„ç‚¹æ•°


1. **æŸ¥é˜…é¡¹ç›®æ–‡æ¡£**ï¼šåœ¨ä¸æµåŠ¨æ€§æ± ç›¸å…³çš„é¡¹ç›®æ–‡æ¡£ä¸­æŸ¥æ‰¾æœ‰å…³æ¯å°æ—¶è·å¾—çš„ç‚¹æ•°çš„ä¿¡æ¯ã€‚é€šå¸¸ï¼Œæ–‡æ¡£ä¼šæ˜¾ç¤ºæ¯å¤©æˆ–æ¯å°æ—¶çš„ç‚¹æ•°ã€‚

2. **è®¡ç®—æ¯å°æ—¶ç‚¹æ•°**ï¼šå¦‚æœæ–‡æ¡£åªæä¾›äº†æ¯å¤©çš„ç‚¹æ•°ï¼Œæ‚¨å¯ä»¥å°†å…¶è½¬æ¢ä¸ºæ¯å°æ—¶ç‚¹æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€å¤©æœ‰24å°æ—¶ï¼Œå°†æ¯å¤©çš„ç‚¹æ•°é™¤ä»¥24ï¼Œå³å¯å¾—åˆ°æ¯å°æ—¶çš„ç‚¹æ•°ã€‚



ç¬¬å››æ­¥ï¼šæŸ¥çœ‹Pendleç»™äºˆçš„é¢å¤–å€æ•°

# English Tutorial
[more infromation about the strategy ](https://docs.google.com/document/d/1MUHDZqcMZwv5h4CJwk_2LLev8zy6GjbSdevnAwpG0LE/edit)

Step 0: Choose the network where the pool is located (currently supports Ethereum, Arbitrum, Mantle).

Step 1: Open the pool's homepage and enter the Market and yt contract addresses.

Please go to the token's homepage and click on the red box.

See the first image.

Next, enter the corresponding address.

See the second image.



Step 3: Determine Points Earned Per Hour

1. **Refer to Project Documentation**: Look for information on the points earned per hour in the project documentation related to the liquidity pool. These documents often provide details on the points earned per day or per hour.

2. **Calculate Points Per Hour**: If the documentation only provides points per day, you can convert it to points per hour. For example, if a day has 24 hours, divide the daily points by 24 to get the points per hour.



Step 4: Check the additional multiplier provided by Pendle.

# **ğŸ»ğŸ»ç¬¬ä¸€éƒ¨åˆ†æ˜¯å¡«å†™å¿…é¡»çš„å’Œé€‰å¡«çš„è¡¨æ ¼ğŸ»ğŸ»**
# **ğŸ»ğŸ»PART1: The first part is to fill out the required and optional formsğŸ»ğŸ»**

# **1. å¿…é¡»å¡«å†™çš„è¡¨å•/Required FormğŸ›¹ğŸ›¹**
"""

# @title å¿…å¡«è¡¨å•/Required Form
import io
import requests
import pandas as pd
import numpy as np
from datetime import datetime, timezone, timedelta
from dateutil import parser
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Network configuration
network = 'ethereum'  # @param {type:"string"}
network_ids = {
    'arbitrum': '/42161',
    'ethereum': '/1',
    'mantle': '/5000'
}

# Initialize session with retry mechanism
session = requests.session()
retry = Retry(total=3, backoff_factor=1)
session.mount('http://', HTTPAdapter(max_retries=retry))
session.mount('https://', HTTPAdapter(max_retries=retry))

# Retrieve network ID
network_id = network_ids.get(network.lower())
if network_id is None:
    raise ValueError("Unsupported network type")

# Construct the request URL and headers
url = f'https://api-v2.pendle.finance/core/v1{network_id}/assets/all'
headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36"
}

# Send request and parse response
response = session.get(url, headers=headers)
data = response.json()

# Function to find valid assets based on given parameters
def find_valid_assets(data, base_type, expiry_key, address):
    """
    Find valid assets matching the specified criteria.

    :param data: The asset data returned by the API
    :param base_type: The type of asset to filter by (e.g., 'YT')
    :param expiry_key: The key indicating the expiry date of the asset
    :param address: The contract address to filter by
    :return: A list of valid assets that meet the criteria
    """
    current_time = datetime.utcnow().replace(tzinfo=timezone.utc)

    def parse_to_utc(date_str):
        dt = parser.parse(date_str)
        return dt.astimezone(timezone.utc)

    def format_expiry(date_str):
        dt = parse_to_utc(date_str)
        return dt.strftime('%Y-%m-%d %H:%M:%S')

    valid_assets = [
        {**item, expiry_key: format_expiry(item[expiry_key])} for item in data
        if item.get('baseType') == base_type and
           item.get('address') == address and
           expiry_key in item
    ]

    return valid_assets

# Form parameter configuration
market_contract = "0x00b321d89a8c36b3929f20b7955080baed706d1b"  # @param {type:"string"}
yt_contract = '0x4f0b4e6512630480b868e62a8a1d3451b0e9192d'  # @param {type:"string"}
start_time = "2023-01-01 00:00:00"
underlying_amount = 1  # @param {type:"number"}
points_per_hour_per_underlying = 0.04  # @param {type:"number"}
pendle_yt_multiplier = 5  # @param {type:"number"}
dark_mode = False  # @param {type:"boolean"}

# Handle time and chart mode
datetime_obj = datetime.strptime(start_time, '%Y-%m-%d %H:%M:%S')
start_time = datetime_obj.replace(tzinfo=timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z')
points = points_per_hour_per_underlying

mode = 'plotly_dark' if dark_mode else 'plotly_white'

# Find valid YT assets
valid_assets = find_valid_assets(data, 'YT', 'expiry', yt_contract)
if not valid_assets:
    raise ValueError("No valid assets found with the given parameters")

symbol = valid_assets[0]['symbol']
maturity = valid_assets[0]['expiry']

"""# **2. å¡«å†™é€‰å¡«è¡¨å• #1 å¯ä»¥è‡ªåŠ¨åˆ†æä½ çš„æŠ•èµ„æƒ…å†µï¼ŒåŒæ—¶åœ¨å›¾ç‰‡ä¸­ä¼šä¸ªæ€§åŒ–å±•ç¤º**
# **2. Filling out the optional form #1 allows automatic analysis of your investment situation, with personalized visualization in the image.**

"""

# @title é€‰å¡«è¡¨å• #1 | Optional Form #1
turn_on_auto_analysis_1 = False # @param {type:"boolean"}
yt_purchase_time = "2024-08-08 23:00:00" # @param {type:"string"}
underlying_invest_amount = 1 # @param {type:"number"}

"""# **3. é€‰å¡«çš„è¡¨å• #2 å¯ä»¥ä¸ºä½ æ¨¡æ‹Ÿè®¾ç½®limit orderå¦‚æœæˆäº¤åçš„çš„é¢„æœŸæ”¶ç›Š**
# **3. Optional Form #2 can simulate setting a limit order and the expected profit after it is filled**
"""

# @title é€‰å¡«è¡¨å• #2 / Optional Form #2
turn_on_auto_analysis_2 = False # @param {type:"boolean"}
limmit_order_yt_estimated_purchase_time = "2024-08-08 06:00:00" # @param {type:"string"}
limmit_order_implied_apy_0_to_1 = 0.05 # @param {type:"number"}
limmit_order_underlying_invest_amount = 1 # @param {type:"number"}

"""#  **ğŸ¥°ğŸ¥°ç¬¬äºŒéƒ¨åˆ†è¿è¡Œå…¨éƒ¨ä»£ç  CTRL+F9ğŸ¥°ğŸ¥°**
#  **ğŸ¥°ğŸ¥°PART 2 : RUN THE NOTEBOOK ! CTRL+F9ğŸ¥°ğŸ¥°**
"""

# @title æ•°æ®è‡ªåŠ¨è·å–éƒ¨åˆ†/Data automatic acquisition part
import requests
import pandas as pd
from datetime import datetime, timezone
import io

class DataAcquisition:
    def __init__(self, market_contract, yt_contract, start_time_str, network):
        self.session = self._init_session()
        self.market_contract = market_contract
        self.yt_contract = yt_contract
        self.start_time_str = start_time_str
        self.end_time_str = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.000Z')
        self.interval = '1h'
        self.network_id = self._get_network_id(network)
        self.url_apy = f'https://api-v2.pendle.finance/core/v1{self.network_id}/markets/{self.market_contract}/apy-history-1ma'
        self.url_ohlcv_yteth = f'https://api-v2.pendle.finance/core/v3{self.network_id}/prices/{self.yt_contract}/ohlcv'
        self.headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36"
        }

    @staticmethod
    def _init_session():
        """Initialize the session with retry capability."""
        session = requests.Session()
        retry = requests.packages.urllib3.util.retry.Retry(total=3, backoff_factor=1)
        session.mount('http://', requests.adapters.HTTPAdapter(max_retries=retry))
        session.mount('https://', requests.adapters.HTTPAdapter(max_retries=retry))
        return session

    @staticmethod
    def _get_network_id(network):
        """Retrieve the network ID based on the network name."""
        network_ids = {
            'arbitrum': '/42161',
            'ethereum': '/1',
            'mantle': '/5000'
        }
        network_id = network_ids.get(network.lower())
        if network_id is None:
            raise ValueError("Unsupported network type")
        return network_id

    def fetch_yteth_ohlcv(self):
        """Fetch OHLCV data for the YT contract."""
        params = {
            "time_frame": "hour",
            "timestamp_start": self.start_time_str,
            "timestamp_end": self.end_time_str
        }
        response = self.session.get(self.url_ohlcv_yteth, headers=self.headers, params=params)
        results = response.json().get('results', [])
        data = [
            [datetime.fromisoformat(item['time'].rstrip('Z')), item['open'], item['high'], item['low'], item['close'], item.get('volume', 0)]
            for item in results
        ]
        return pd.DataFrame(data, columns=['Time', 'Open', 'High', 'Low', 'Close', 'Volume'])

    def fetch_apy(self):
        """Fetch APY data for the market contract."""
        params = {
            "time_frame": "hour",
            "timestamp_start": self.start_time_str,
            "timestamp_end": self.end_time_str
        }
        response = self.session.get(self.url_apy, headers=self.headers, params=params)
        if response.status_code == 200:
            data = response.json()
            if 'results' in data:
                csv_data = data['results']
                df = pd.read_csv(io.StringIO(csv_data))
                df['timestamp'] = pd.to_datetime(df['timestamp'], unit='s')
                return df
            else:
                print("No results found in the API response")
                return pd.DataFrame()
        else:
            print(f"Failed to retrieve data with status code: {response.status_code}")
            return pd.DataFrame()

    def run(self):
        """Execute the data retrieval process and combine the results."""
        df = self.fetch_apy()
        volume = self.fetch_yteth_ohlcv()['Volume']
        if not df.empty:
            df['volume'] = volume
            df.drop(index=df.index[-1], axis=0, inplace=True)  # Drop the last row if necessary
            return df
        else:
            print("No data to display.")
            return pd.DataFrame()

# Initialize the data acquisition instance and run the data retrieval process
data_acquisition = DataAcquisition(market_contract, yt_contract, start_time, network=network)
df = data_acquisition.run()
df

# @title ğŸ›¹æ•°æ®è®¡ç®—éƒ¨åˆ†çš„éšè—ä»£ç  | Hidden code of data calculation part

# Convert maturity time to datetime object
maturity_time = datetime.strptime(maturity, '%Y-%m-%d %H:%M:%S')

# Calculate hours to maturity for each timestamp in the DataFrame
df['hours_to_maturity'] = (maturity_time - df['timestamp']).dt.total_seconds() / 3600
df['Time'] = pd.to_datetime(df['timestamp'])

# Calculate yt/underling and long_yield_apy based on APYs and time to maturity
df['yt/underling'] = (df['impliedApy'] + 1) ** (df['hours_to_maturity'] / 8760) - 1
df['long_yield_apy'] = (1 + (df['underlyingApy'] - df['impliedApy']) / df['impliedApy']) ** (8760 / df['hours_to_maturity']) - 1

# Calculate price and weighted points
price = df['yt/underling']
time_diff_hours = (maturity_time - df['Time']).dt.total_seconds() / 3600
df['points'] = 1 / price * time_diff_hours * points * underlying_amount * pendle_yt_multiplier

# Generate a date range in hourly intervals from the first timestamp to maturity
h_range = pd.date_range(start=df['Time'].iloc[0], end=maturity_time, freq='H')

# Calculate the average implied APY weighted by volume
implied_apy_average = (df['impliedApy'] * df['volume'] / df['volume'].sum()).sum()

# Calculate the fair value curve based on the average implied APY
fair_value_curve = 1 - 1 / (1 + implied_apy_average) ** (((maturity_time - h_range).total_seconds() / 3600) / 8760)

# Calculate weighted points for each row
df['weighted_points'] = df['points'] * df['volume'] / df['volume'].sum()

# Sum weighted points per underlying asset
weighted_points_per_underlying = df['weighted_points'].sum()

# Add fair value curve and calculate the difference between fair value and yt/underling
df['fair'] = fair_value_curve[:len(df)]
df['difference'] = df['fair'] - df['yt/underling']

"""# ã€å¯é€‰ã€‘è‡ªåŠ¨åˆ†ææŠ•èµ„æƒ…å†µ | [Optional] Auto-Analyze Investment Situation | ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€‘æŠ•è³‡çŠ¶æ³ã®è‡ªå‹•åˆ†æ | ã‚ãªãŸã®æŠ•è³‡çŠ¶æ³

å¦‚æœä½ æ²¡æœ‰å¡«å†™é€‰å¡«è¡¨å•ï¼Œé‚£ä¹ˆè·³è¿‡è¿™ä¸ªéƒ¨åˆ†ä¹‹é—´çœ‹åé¢çš„YTä¹°å…¥ç­–ç•¥å³å¯ï¼Œ

å¦‚æœä½ å¡«å†™äº†é€‰å¡«çš„è¡¨å•ï¼Œä¸‹é¢çš„ä»£ç å°†ä¼šå¸®åŠ©ä½ è®¡ç®—ä½ çš„æŠ•èµ„æƒ…å†µã€‚ä¸ºäº†ä¿è¯åˆ†æç»“æœçš„å¯é æ€§ï¼Œé™¤äº†éœ€è¦å¡«å†™é€‰å¡«è¡¨å•å¤–ï¼Œä½ è¿˜éœ€è¦ç¡®ä¿å¿…å¡«è¡¨å•çš„ä¿¡æ¯æ˜¯æ­£ç¡®çš„ã€‚

If you didn't fill out the optional form, skip this section and proceed to the YT Purchase Strategy.

If you did fill out the optional form, the following code will help you calculate your investment situation. To ensure the reliability of the analysis results, you need to fill out the optional form and ensure that the mandatory form information is correct.

ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ã«è¨˜å…¥ã—ã¦ã„ãªã„å ´åˆã€ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ã€æ¬¡ã®YTè³¼å…¥æˆ¦ç•¥ã«é€²ã‚“ã§ãã ã•ã„ã€‚

ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ã«è¨˜å…¥ã—ãŸå ´åˆã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚ãªãŸã®æŠ•è³‡çŠ¶æ³ã‚’è¨ˆç®—ã™ã‚‹ã®ã«å½¹ç«‹ã¡ã¾ã™ã€‚åˆ†æçµæœã®ä¿¡é ¼æ€§ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã«ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ã‚’è¨˜å…¥ã™ã‚‹ã ã‘ã§ãªãã€å¿…é ˆãƒ•ã‚©ãƒ¼ãƒ ã®æƒ…å ±ãŒæ­£ã—ã„ã“ã¨ã‚’ç¢ºèªã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
"""

# @title 1. è‡ªåŠ¨åˆ†ææŠ•èµ„æƒ…å†µ | Auto-Analyze Investment Situation

def auto_analyze_investment(df, yt_purchase_time, underlying_invest_amount, maturity_time, symbol, network, pendle_yt_multiplier, points):
    """Automatically analyze the investment situation based on provided data and parameters."""

    # Convert the purchase time to datetime object
    yt_purchase_time_dt = datetime.strptime(yt_purchase_time, '%Y-%m-%d %H:%M:%S')
    yt_purchase_time_near = yt_purchase_time_dt.replace(minute=0, second=0, microsecond=0)

    # Validate that the purchase time is within the available data range
    if yt_purchase_time_dt < df['Time'].min() or yt_purchase_time_dt > df['Time'].max():
        raise ValueError("|Investment time is out of range|æŠ•èµ„æ—¶é—´è¶…å‡ºèŒƒå›´|")

    # Find the nearest times before and after the purchase time
    nearest_times = df['Time'].sort_values().unique()
    previous_time = nearest_times[nearest_times <= yt_purchase_time_near].max()
    next_time = nearest_times[nearest_times > yt_purchase_time_near].min()

    if previous_time is None or next_time is None:
        raise ValueError("|No price data found for the investment time point|æ²¡æœ‰æ‰¾åˆ°ä¸æŠ•èµ„æ—¶é—´ç‚¹ç›¸ç¬¦çš„ä»·æ ¼æ•°æ®|")

    # Interpolate the YT price and volume at the purchase time
    distance_to_previous = (yt_purchase_time_near - previous_time).total_seconds()
    distance_to_next = (next_time - yt_purchase_time_near).total_seconds()

    weight_previous = distance_to_next / (distance_to_previous + distance_to_next)
    weight_next = distance_to_previous / (distance_to_previous + distance_to_next)

    yt_price_when_purchase = (
        weight_previous * df.loc[df['Time'] == previous_time, 'yt/underling'].values[0]
        + weight_next * df.loc[df['Time'] == next_time, 'yt/underling'].values[0]
    )

    volume_when_purchase = (
        weight_previous * df.loc[df['Time'] == previous_time, 'volume'].values[0]
        + weight_next * df.loc[df['Time'] == next_time, 'volume'].values[0]
    )

    # Calculate various metrics related to the investment
    time_diff_hours_for_auto_analysis = (maturity_time - yt_purchase_time_dt).total_seconds() / 3600
    leverage = 1 / yt_price_when_purchase * pendle_yt_multiplier
    points_for_auto_analysis = 1 / yt_price_when_purchase * time_diff_hours_for_auto_analysis * points * underlying_invest_amount * pendle_yt_multiplier
    points_for_auto_analysis_per_underlying = points_for_auto_analysis / underlying_invest_amount

    exceed_count = df[df['points'] < points_for_auto_analysis_per_underlying].shape[0]
    total_count = df.shape[0]
    percent_exceed = (exceed_count / total_count) * 100

    # Create the output string
    output = (
        "===================\n"
        f"ğŸŒŸã€{symbol} on {network} è‡ªåŠ¨åˆ†ææŠ•èµ„æƒ…å†µã€‘ğŸŒŸ\n"
        "===================\n"
        f"| â° è´­ä¹°æ—¶é—´ï¼š{yt_purchase_time}\n"
        f"| ğŸ’° YTè´­ä¹°ä»·æ ¼ï¼š{yt_price_when_purchase:.4f}\n"
        f"| ğŸ”§ æ æ†å€æ•°ï¼ˆå«pendle_yt_multiplierï¼‰ï¼š{leverage:.2f} å€\n"
        f"| ğŸ“ˆ æ‚¨åˆ°æœŸæ—¶çš„æ”¶ç›Šï¼š{points_for_auto_analysis:.2f} ç§¯åˆ†\n"
        f"| ğŸ“Š æ‚¨åˆ°æœŸæ¯å•ä½åŸºç¡€èµ„äº§çš„æ”¶ç›Šï¼š{points_for_auto_analysis_per_underlying:.2f} ç§¯åˆ†\n"
        f"| ğŸ“Š æ‚¨åˆ°æœŸæ¯å•ä½ç§¯åˆ†çš„æˆæœ¬ï¼š{1 / points_for_auto_analysis_per_underlying:.8f} åŸºç¡€èµ„äº§/ç§¯åˆ†\n"
        f"| ğŸ† å¸‚åœºæœ€é«˜åˆ°æœŸæ¯å•ä½åŸºç¡€èµ„äº§çš„ç§¯åˆ†æ”¶ç›Šï¼š{df['points'].max():.2f} ç§¯åˆ†\n"
        f"| ğŸ“‰ å¸‚åœºæœ€ä½åˆ°æœŸæ¯å•ä½åŸºç¡€èµ„äº§çš„ç§¯åˆ†æ”¶ç›Šï¼š{df['points'].min():.2f} ç§¯åˆ†\n"
        f"| âš–ï¸ å¸‚åœºå¹³å‡åˆ°æœŸæ¯å•ä½åŸºç¡€èµ„äº§çš„ç§¯åˆ†æ”¶ç›Šï¼š{weighted_points_per_underlying:.2f}\n"
        "---\n"
        f"ğŸ‰ æ‚¨å·²è¶…è¿‡äº† {percent_exceed:.2f}% çš„ç”¨æˆ·ï¼\n"
        "===================\n"
        "âœ¨ã€{symbol} on {network} Auto-Analyze Investment Situationã€‘âœ¨\n"
        "===================\n"
        f"| â° Purchase Time: {yt_purchase_time}\n"
        f"| ğŸ’° YT Purchase Price: {yt_price_when_purchase:.4f}\n"
        f"| ğŸ”§ Leverage (include pendle_yt_multiplier): {leverage:.2f}x\n"
        f"| ğŸ“ˆ Points at Maturity: {points_for_auto_analysis:.2f} points\n"
        f"| ğŸ“Š Points per Unit of Underlying Asset at Maturity: {points_for_auto_analysis_per_underlying:.2f} points\n"
        f"| ğŸ“Š Cost per Unit of Point at Maturity: {1 / points_for_auto_analysis_per_underlying:.8f} underlying/point \n"
        f"| ğŸ† Market Maximum Points per Unit at Maturity: {df['points'].max():.2f} points \n"
        f"| ğŸ“‰ Market Minimum Points per Unit at Maturity: {df['points'].min():.2f} points \n"
        f"| âš–ï¸ Market Average Points per Unit at Maturity: {weighted_points_per_underlying:.2f} points \n"
        "---\n"
        f"ğŸ‰ You have outperformed {percent_exceed:.2f}% of users!"
    )

    print(output)
    return points_for_auto_analysis_per_underlying

# Execute the analysis if the auto-analysis is turned on
if turn_on_auto_analysis_1:
    points_for_auto_analysis_per_underlying = auto_analyze_investment(df, yt_purchase_time, underlying_invest_amount, maturity_time, symbol, network, pendle_yt_multiplier, points)

# @title 2. æ¨¡æ‹Ÿé™ä»·å•ç»“æœ | Simulated Limit Order Results

def simulate_limit_order(df, limmit_order_yt_estimated_purchase_time, limmit_order_underlying_invest_amount, maturity_time, limmit_order_implied_apy_0_to_1, symbol, network, pendle_yt_multiplier, points):
    """Simulate the results of a limit order based on provided data and parameters."""

    # Convert the estimated purchase time to datetime object
    limmit_order_yt_purchase_time_dt = datetime.strptime(limmit_order_yt_estimated_purchase_time, '%Y-%m-%d %H:%M:%S')
    limmit_order_yt_purchase_time_near = limmit_order_yt_purchase_time_dt.replace(minute=0, second=0, microsecond=0)

    # Calculate the YT price at the estimated purchase time
    limmit_order_yt_price_when_purchase = (limmit_order_implied_apy_0_to_1 + 1) ** (
        (maturity_time - limmit_order_yt_purchase_time_dt).total_seconds() / 31536000) - 1

    # Calculate various metrics related to the limit order investment
    limmit_order_time_diff_hours_for_auto_analysis = (maturity_time - limmit_order_yt_purchase_time_dt).total_seconds() / 3600
    limmit_order_leverage = 1 / limmit_order_yt_price_when_purchase * pendle_yt_multiplier
    limmit_order_points_for_auto_analysis = 1 / limmit_order_yt_price_when_purchase * limmit_order_time_diff_hours_for_auto_analysis * points * limmit_order_underlying_invest_amount * pendle_yt_multiplier
    limmit_order_points_for_auto_analysis_per_underlying = limmit_order_points_for_auto_analysis / limmit_order_underlying_invest_amount
    limmit_order_weighted_points_for_auto_analysis_per_underlying = df['volume'].mean() / df['volume'].sum() * limmit_order_points_for_auto_analysis_per_underlying

    # Determine the percentage of users outperformed by this limit order
    limmit_order_exceed_count = df[df['weighted_points'] < limmit_order_weighted_points_for_auto_analysis_per_underlying].shape[0]
    limmit_order_total_count = df.shape[0]
    limmit_order_percent_exceed = (limmit_order_exceed_count / limmit_order_total_count) * 100

    # Create the output string
    output = (
        "===================\n"
        f"ğŸŒŸã€{symbol} on {network} é™ä»·å•æŠ•èµ„åˆ†ææƒ…å†µã€‘ğŸŒŸ\n"
        "===================\n"
        f"| â° é¢„è®¡çš„æˆäº¤æ—¶é—´ï¼š{limmit_order_yt_estimated_purchase_time}\n"
        f"| ğŸ’° é™ä»·å•YTè´­ä¹°ä»·æ ¼ï¼š{limmit_order_yt_price_when_purchase:.4f}\n"
        f"| ğŸ”§ æ æ†å€æ•°ï¼ˆå«pendle_yt_multiplierï¼‰ï¼š{limmit_order_leverage:.2f} å€\n"
        f"| ğŸ“ˆ æ‚¨åˆ°æœŸæ—¶çš„æ”¶ç›Šï¼š{limmit_order_points_for_auto_analysis:.2f} ç§¯åˆ†\n"
        f"| ğŸ“Š æ‚¨åˆ°æœŸæ¯å•ä½åŸºç¡€èµ„äº§çš„æ”¶ç›Šï¼š{limmit_order_points_for_auto_analysis_per_underlying:.2f} ç§¯åˆ†\n"
        f"| ğŸ† å¸‚åœºæœ€é«˜åˆ°æœŸæ¯å•ä½åŸºç¡€èµ„äº§çš„æ”¶ç›Šï¼š{df['points'].max():.2f} ç§¯åˆ†\n"
        f"| ğŸ“‰ å¸‚åœºæœ€ä½åˆ°æœŸæ¯å•ä½åŸºç¡€èµ„äº§çš„æ”¶ç›Šï¼š{df['points'].min():.2f} ç§¯åˆ†\n"
        f"| âš–ï¸ å¸‚åœºå¹³å‡åˆ°æœŸæ¯å•ä½åŸºç¡€èµ„äº§çš„æ”¶ç›Šï¼š{weighted_points_per_underlying:.2f}\n"
        "---\n"
        f"ğŸ‰ æ‚¨å°†è¶…è¿‡ {limmit_order_percent_exceed:.2f}% çš„ç”¨æˆ·ï¼\n"
        "===================\n"
        f"âœ¨ã€{symbol} on {network} Auto-Analyze Investment Situation For Limit Orderã€‘âœ¨\n"
        "===================\n"
        f"| â° Estimated closing time: {limmit_order_yt_estimated_purchase_time}\n"
        f"| ğŸ’° Limit Order YT Purchase Price: {limmit_order_yt_price_when_purchase:.4f}\n"
        f"| ğŸ”§ Leverage (include pendle_yt_multiplier): {limmit_order_leverage:.2f}x\n"
        f"| ğŸ“ˆ Points at Maturity: {limmit_order_points_for_auto_analysis:.2f}\n"
        f"| ğŸ“Š Points per Unit of Underlying Asset at Maturity: {limmit_order_points_for_auto_analysis_per_underlying:.2f}\n"
        f"| ğŸ† Market Maximum Points per Unit at Maturity: {df['points'].max():.2f}\n"
        f"| ğŸ“‰ Market Minimum Points per Unit at Maturity: {df['points'].min():.2f}\n"
        f"| âš–ï¸ Market Average Points per Unit at Maturity: {weighted_points_per_underlying:.2f}\n"
        "---\n"
        f"ğŸ‰ You will outperform {limmit_order_percent_exceed:.2f}% of users!"
    )

    print(output)

# Execute the simulation if the auto-analysis is turned on
if turn_on_auto_analysis_2:
    simulate_limit_order(df, limmit_order_yt_estimated_purchase_time, limmit_order_underlying_invest_amount, maturity_time, limmit_order_implied_apy_0_to_1, symbol, network, pendle_yt_multiplier, points)

"""# HERE IS THE STRATEGY | ç­–ç•¥ä»‹ç» | ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼

## EGLISH VERSION
To understand this strategy, one must first comprehend what YT (Yield Token) represents: it signifies ownership over future earnings. On the Pendle platform, investors can purchase YT to secure future yields on a particular asset (like ETH). As YT nears its expiry, its value theoretically decreases because the window of earnings it represents grows shorter.

The core of the strategy is to exploit this time sensitivity for a higher yield return. In essence, purchasing YT as it approaches expiry can provide greater leverage due to the effect of time compression.

Here are the specific steps of the strategy:

1. **Monitor YT Price Relative to Its Fair Value**: The fair value (represented by the yellow dashed line in the graph later) refers to the theoretical value of YT, which can be depicted as a line decreasing linearly from the pool's initial average to zero. The buying opportunity you are looking for occurs when YTâ€™s market price falls below this fair value line.

2. **Assess Market Sentiment and Events**: For instance, an airdrop event from EtherFi could cause nonlinear price movements. Such events could present buying opportunities.

3. **Determine the Timing for Purchase**: Combine price monitoring and market analysis to purchase YT when its market price is below the estimated fair value line, typically indicating that other investors may have undervalued the forthcoming returns.

4. **Analyze Flat and Downtrend Movements**: If the price enters a flat phase, where there's little to no significant change over a period, it may not be the best time to buy, as the flat movement indicates that the actual value is diminishing but is not reflected in the market price. Conversely, if the price drops rapidly, surpassing the fair valueâ€™s decline rate and YTâ€™s market price falls below the fair value's dashed yellow line, it may indicate an overreaction by the market, devaluing YT excessively. At this point, a purchase could result in gaining more points.

> If you care about the exact amount of points, you need to precisely set the value of `points_per_hour_per_underlying`,`underlying_invest_amount`, `pendle_yt_multiplier`. If you are only concerned about when it's more cost-effective to buy YT to obtain points above the average level, then you can just enter any number

## ä¸­æ–‡ç‰ˆæœ¬ï¼š
è¦ç†è§£è¿™ä¸ªç­–ç•¥ï¼Œé¦–å…ˆéœ€è¦çŸ¥é“YTï¼ˆYield Tokenï¼‰æ˜¯ä»€ä¹ˆï¼šå®ƒä»£è¡¨äº†ä¸€ç§å¯¹æœªæ¥æ”¶ç›Šçš„æ‰€æœ‰æƒã€‚åœ¨Pendleå¹³å°ï¼ŒæŠ•èµ„è€…å¯ä»¥é€šè¿‡è´­ä¹°YTæ¥è·å¾—æŸç§èµ„äº§ï¼ˆæ¯”å¦‚ETHï¼‰æœªæ¥çš„æ”¶ç›Šã€‚éšç€YTä¸´è¿‘åˆ°æœŸï¼Œå®ƒçš„ä»·å€¼ç†è®ºä¸Šä¼šä¸‹é™ï¼Œå› ä¸ºå®ƒä»£è¡¨çš„æ”¶ç›Šæ—¶é—´çª—å£å˜çŸ­ã€‚

ç­–ç•¥æ ¸å¿ƒåœ¨äºåˆ©ç”¨è¿™ç§æ—¶é—´æ•æ„Ÿæ€§æ¥è·å¾—è¾ƒé«˜çš„ç§¯åˆ†å›æŠ¥ã€‚ç®€è€Œè¨€ä¹‹ï¼Œå½“æ‚¨åœ¨YTå³å°†åˆ°æœŸæ—¶è´­ä¹°å®ƒï¼Œç”±äºæ—¶é—´çš„å‹ç¼©æ•ˆåº”ï¼Œæ‚¨æ‰€èƒ½è·å¾—çš„æ æ†æ•ˆåº”æ›´å¤§ã€‚

ä»¥ä¸‹æ˜¯ç­–ç•¥çš„å…·ä½“æ­¥éª¤ï¼š

1. **ç›‘æµ‹YTä»·æ ¼ä¸å…¶å…¬å…ä»·å€¼**ï¼šå…¬å…ä»·å€¼ï¼ˆåé¢å›¾ä¸­é»„è‰²çš„è™šçº¿ï¼‰æŒ‡çš„æ˜¯YTçš„ç†è®ºä»·å€¼ï¼Œå¯ä»¥ç”¨ä¸€æ¡ä»æ± å­å¼€å§‹æ—¶çš„å‡å€¼çº¿æ€§é€’å‡åˆ°0çš„çº¿æ¥è¡¨ç¤ºã€‚æ‚¨è¦å¯»æ‰¾çš„è´­ä¹°æœºä¼šæ˜¯YTçš„å¸‚åœºä»·æ ¼ä½äºè¿™æ¡å…¬å…ä»·å€¼çº¿ã€‚

2. **è¯„ä¼°å¸‚åœºæƒ…ç»ªå’Œäº‹ä»¶**ï¼šæ¯”å¦‚EtherFiçš„ç©ºæŠ•äº‹ä»¶å¯èƒ½ä¼šå¯¼è‡´éçº¿æ€§çš„ä»·æ ¼å˜åŠ¨ã€‚è¿™æ ·çš„äº‹ä»¶å¯èƒ½ä¼šæä¾›è´­ä¹°æœºä¼šã€‚

3. **ç¡®å®šè´­ä¹°æ—¶æœº**ï¼šç»“åˆä»·æ ¼ç›‘æµ‹å’Œå¸‚åœºåˆ†æï¼Œæ‚¨è¦åœ¨å¸‚åœºä»·æ ¼ä½äºå…¬å…ä»·å€¼çº¿æ—¶ä¹°å…¥YTï¼Œè¿™é€šå¸¸æ„å‘³ç€å…¶ä»–æŠ•èµ„è€…ä½ä¼°äº†å³å°†åˆ°æ¥çš„æ”¶ç›Šã€‚

4. **åˆ†ææ¨ªç›˜ä¸ä¸‹è·Œè¶‹åŠ¿**ï¼šå¦‚æœä»·æ ¼å‡ºç°æ¨ªç›˜ï¼Œå³åœ¨ä¸€æ®µæ—¶é—´å†…ä»·æ ¼æ²¡æœ‰æ˜¾è‘—å˜åŠ¨ï¼Œåˆ™æ­¤æ—¶ä¹°å…¥å¯èƒ½ä¸ä½³ï¼Œå› ä¸ºæ¨ªç›˜æ„å‘³ç€å®é™…ä»·å€¼é™ä½ä½†å¸‚åœºä»·æ ¼æ²¡æœ‰åæ˜ å‡ºæ¥ã€‚ç›¸åï¼Œå¦‚æœä»·æ ¼å¿«é€Ÿä¸‹è·Œï¼Œè¶…è¿‡äº†å…¬å…ä»·å€¼çš„ä¸‹è·Œé€Ÿåº¦ï¼Œå¹¶ä¸”YTçš„å¸‚åœºä»·æ ¼ä½äºæ¢è‰²è™šçº¿çš„å…¬å…ä»·æ ¼ï¼Œè¿™è¡¨æ˜å¸‚åœºå¯èƒ½å¯¹YTçš„ä»·å€¼æœ‰è¿‡åº¦è´¬å€¼çš„ååº”ï¼Œæ­¤æ—¶ä¹°å…¥å¯èƒ½ä¼šè·å¾—æ›´å¤šç§¯åˆ†ã€‚

> å¦‚æœæ‚¨å…³å¿ƒç¡®åˆ‡çš„ç‚¹æ•°ï¼Œåˆ™éœ€è¦å‡†ç¡®è®¾ç½® `points_per_hour_per_underlying`,`underlying_invest_amount`, `pendle_yt_multiplier` çš„å€¼ã€‚å¦‚æœæ‚¨åªå…³å¿ƒåœ¨ä»€ä¹ˆæ—¶å€™è´­ä¹° YT æ›´å…·æˆæœ¬æ•ˆç›Šä»¥è·å¾—è¶…è¿‡å¹³å‡æ°´å¹³çš„ç‚¹æ•°ï¼Œé‚£ä¹ˆæ‚¨å¯ä»¥éšæ„è¾“å…¥ä»»ä½•æ•°å­—ã€‚



"""

# @title è‡ªå®šä¹‰æŒ‡æ ‡å‚æ•°|Custom indicator parameters
volatility_window = 48 # @param {type:"integer"}
ma1 = 24 # @param {type:"integer"}
ma2 = 72 # @param {type:"integer"}
ma3 = 216 # @param {type:"integer"}
rsi_window = 72 # @param {type:"integer"}
ema1 = 12 # @param {type:"integer"}
ema2 = 26 # @param {type:"integer"}
macd_signal = 9 # @param {type:"integer"}

if len(df) >= volatility_window:
    df['volatility'] = df['yt/underling'].rolling(window=volatility_window).std().bfill()
else:
    df['volatility'] = np.nan
    print('window is too big for volatility')

df['moving_average_20'] = df['yt/underling'].rolling(window=ma1).mean().bfill()
df['moving_average_50'] = df['yt/underling'].rolling(window=ma2).mean().bfill()
df['moving_average_200'] = df['yt/underling'].rolling(window=ma3).mean().bfill()

if len(df) >= rsi_window:
    delta = df['yt/underling'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=rsi_window).mean().bfill()
    loss = (-delta.where(delta < 0, 0)).rolling(window=rsi_window).mean().bfill()
    rs = gain / loss
    df['RSI'] = 100 - (100 / (1 + rs)).bfill()
else:
    df['RSI'] = np.nan

ema12 = df['yt/underling'].ewm(span=ema1, adjust=False).mean().bfill()
ema26 = df['yt/underling'].ewm(span=ema2, adjust=False).mean().bfill()
df['MACD'] = ema12 - ema26
df['Signal Line'] = df['MACD'].ewm(span=macd_signal, adjust=False).mean().bfill()

# @title | YT/underling Price Curve |<br />| YT ä»·æ ¼æ›²çº¿ |
import plotly.graph_objects as go
from datetime import datetime

def plot_yt_price_curve(df, symbol, network, mode, add_volatility=True, add_moving_average=True, add_RSI=True, add_macd=False, yt_purchase_time=None):
    """Plots the YT/underlying price curve with optional indicators and annotations."""

    # Initialize the figure
    fig = go.Figure()

    # Add the YT price curve
    fig.add_trace(go.Scatter(x=df['Time'], y=df['yt/underling'], mode='lines', name='YT Price'))

    # Add optional indicators
    if add_volatility and 'volatility' in df.columns:
        fig.add_trace(go.Scatter(x=df['Time'], y=df['volatility'], mode='lines', name='Volatility', yaxis='y2'))

    if add_moving_average:
        if 'moving_average_20' in df.columns:
            fig.add_trace(go.Scatter(x=df['Time'], y=df['moving_average_20'], mode='lines', name='20-day MA'))
        if 'moving_average_50' in df.columns:
            fig.add_trace(go.Scatter(x=df['Time'], y=df['moving_average_50'], mode='lines', name='50-day MA'))
        if 'moving_average_200' in df.columns:
            fig.add_trace(go.Scatter(x=df['Time'], y=df['moving_average_200'], mode='lines', name='200-day MA'))

    if add_RSI and 'RSI' in df.columns:
        fig.add_trace(go.Scatter(x=df['Time'], y=df['RSI'], mode='lines', name='RSI', yaxis='y3'))

    if add_macd and 'MACD' in df.columns:
        fig.add_trace(go.Scatter(x=df['Time'], y=df['MACD'], mode='lines', name='MACD', yaxis='y4'))
        if 'Signal Line' in df.columns:
            fig.add_trace(go.Scatter(x=df['Time'], y=df['Signal Line'], mode='lines', name='Signal Line', yaxis='y4'))

    # Update layout for dual y-axes and additional y-axes for RSI and MACD
    fig.update_layout(
        title=f'{symbol} on {network} YT/Underlying Asset',
        xaxis_title='Time',
        yaxis_title='YT Price (per Underlying)',
        template=mode,
        yaxis2=dict(
            title='Volatility',
            overlaying='y',
            side='right',
            position=0.85
        ),
        yaxis3=dict(
            title='RSI',
            overlaying='y',
            side='right',
            position=0.90
        ),
        yaxis4=dict(
            title='MACD',
            overlaying='y',
            side='right',
            position=0.95
        )
    )

    # Add a vertical line and annotation for the purchase time if provided
    if yt_purchase_time:
        yt_purchase_time_dt = datetime.strptime(yt_purchase_time, '%Y-%m-%d %H:%M:%S')

        fig.add_vline(x=yt_purchase_time_dt, line_width=3, line_dash="dash", line_color="green")

        fig.add_annotation(
            x=yt_purchase_time_dt,
            y=max(df['yt/underling']),
            text="YT Purchase Time",
            showarrow=True,
            arrowhead=1,
            ax=20,
            ay=-30
        )

    # Display the plot
    fig.show()

# Example of using the function
plot_yt_price_curve(df, symbol, network, mode, add_volatility=True, add_moving_average=True, add_RSI=True, add_macd=False, yt_purchase_time=yt_purchase_time if turn_on_auto_analysis_1 else None)

# @title | Total number of points earned from underlying investment in YT at a certain time |<br />| åœ¨æŸä¸ªæ—¶é—´ç‚¹ç”¨åº•å±‚èµ„äº§æŠ•èµ„YTèµšå–çš„ç‚¹æ•° |

import plotly.graph_objects as go
from datetime import datetime

def plot_points_earned(df, symbol, network, mode, underlying_amount, yt_purchase_time=None):
    """Plots the total number of points earned from underlying investment in YT at a certain time."""

    # Initialize the figure
    fig = go.Figure(data=go.Scatter(x=df['Time'], y=df['points'], mode='lines'))

    # Update layout with titles and axis labels
    fig.update_layout(
        title=f'{symbol} on {network} <br />|Total number of points earned from {underlying_amount} underlying investment in YT at a certain time|<br />|åœ¨æŸä¸ªæ—¶é—´ç‚¹ç”¨{underlying_amount}åº•å±‚èµ„äº§æŠ•èµ„YTèµšå–çš„ç‚¹æ•°|<br />|',
        xaxis_title='Time',
        yaxis_title='Points',
        template=mode
    )

    # Add a vertical line and annotation for the purchase time if provided
    if yt_purchase_time:
        yt_purchase_time_dt = datetime.strptime(yt_purchase_time, '%Y-%m-%d %H:%M:%S')

        fig.add_vline(x=yt_purchase_time_dt, line_width=3, line_dash="dash", line_color="green")

        fig.add_annotation(
            x=yt_purchase_time_dt,
            y=max(df['points']),
            text="YT Purchase Time",
            showarrow=True,
            arrowhead=1,
            ax=20,
            ay=-30
        )

    # Display the plot
    fig.show()

# Example of using the function
plot_points_earned(df, symbol, network, mode, underlying_amount, yt_purchase_time=yt_purchase_time if turn_on_auto_analysis_1 else None)

# @title YT Price/Points Earned/Fair Value Curve of YT
Add_difference_curve = False # @param {type:"boolean"}
def plot_yt_price_points_curve(df, h_range, fair_value_curve, symbol, network, mode, underlying_amount, yt_purchase_time=None,
                               add_difference_curve=False):
    """Plots YT Price, Points Earned, and optionally the Difference Curve."""

    fig = go.Figure()

    # Add YT Price and Points Earned curves
    fig.add_trace(go.Scatter(x=df['Time'], y=df['yt/underling'], mode='lines', name='YT Price', yaxis='y'))
    fig.add_trace(go.Scatter(x=df['Time'], y=df['points'], mode='lines', name='Points Earned', yaxis='y2'))

    if add_difference_curve:
        fig.add_trace(go.Scatter(x=df['Time'], y=df['difference'], mode='lines', name='Difference between Fair and Market Price', yaxis='y3'))

    # Add Fair Value Curve
    fig.add_trace(go.Scatter(
        x=h_range,
        y=fair_value_curve,
        mode='lines',
        name='Fair Value Curve of YT',
        line=dict(color='yellow', dash='dot', width=3),
        yaxis='y'
    ))

    # Layout settings
    yaxis_config = dict(title='YT Price', side='left')
    yaxis2_config = dict(title='Points Earned', overlaying='y', side='right')

    layout_config = {
        'title': f'{symbol} on {network} [{underlying_amount} underlying coin]<br />|BUY YT WHEN THE yt Price IS UNDER THE FAIR VALUE CURVE TO MAXIMIZE POINTS EARNED|<br />|åœ¨ytä»·æ ¼ä½äºå…¬å¹³ä»·å€¼æ›²çº¿æ—¶è´­ä¹°ytä»¥æœ€å¤§åŒ–è·å¾—çš„ç§¯åˆ†|<br />|ytä¾¡æ ¼ãŒå…¬æ­£ä¾¡å€¤æ›²ç·šã‚ˆã‚Šã‚‚ä½ã„å ´åˆã«ytã‚’è³¼å…¥ã—ã¦ãƒã‚¤ãƒ³ãƒˆã‚’æœ€å¤§åŒ–ã™ã‚‹|',
        'xaxis_title': 'Certain Time of Purchasing YT',
        'yaxis': yaxis_config,
        'yaxis2': yaxis2_config,
        'template': mode
    }

    if add_difference_curve:
        yaxis3_config = dict(title='Difference', overlaying='y', side='right')
        layout_config['yaxis3'] = yaxis3_config

    fig.update_layout(**layout_config)

    # Add vertical line and annotation for the purchase time if provided
    if yt_purchase_time:
        yt_purchase_time_dt = datetime.strptime(yt_purchase_time, '%Y-%m-%d %H:%M:%S')

        fig.add_vline(x=yt_purchase_time_dt, line_width=3, line_dash="dash", line_color="green")

        fig.add_annotation(
            x=yt_purchase_time_dt,
            y=max(df['yt/underling']) * 0.01,
            text="YT Purchase Time",
            showarrow=True,
            arrowhead=1,
            ax=20,
            ay=-30
        )

    # Display the plot
    fig.show()

    # Print the weighted Implied APY used to calculate the fair value curve

    print(f'The weighted Implied APY used to calculate the fair value curve is: {implied_apy_average:.2%}')
    print(f'ç”¨äºè®¡ç®—å…¬å…ä»·å€¼æ›²çº¿çš„åŠ æƒéšå«å¹´æ”¶ç›Šç‡æ˜¯ï¼š{implied_apy_average:.2%}')
    print(f'å…¬æ­£ãªä¾¡å€¤æ›²ç·šã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚ŒãŸåŠ é‡ã‚¤ãƒ³ãƒ—ãƒ©ã‚¤ãƒ‰APYã¯ï¼š{implied_apy_average:.2%}')

# Example of using the function
plot_yt_price_points_curve(df, h_range, fair_value_curve, symbol, network, mode, underlying_amount, yt_purchase_time=yt_purchase_time if turn_on_auto_analysis_1 else None, add_difference_curve=Add_difference_curve)

# @title | Long Yield APY V.S. Implied APY |<br />| é•¿æœŸæ”¶ç›Šç‡APYä¸éšå«APY |<br />| é•·æœŸåç›Šç‡APYå¯¾æš—é»™ã®APY |
import plotly.graph_objects as go
from datetime import datetime

def plot_yield_vs_implied_apy(df, symbol, network, mode, yt_purchase_time=None):
    """Plots Long Yield APY versus Implied APY with optional annotations for YT purchase time."""

    # Initialize the figure
    fig = go.Figure()

    # Add Long Yield APY and Implied APY curves
    fig.add_trace(go.Scatter(x=df['Time'], y=df['long_yield_apy'], mode='lines', name='Long Yield APY', yaxis='y'))
    fig.add_trace(go.Scatter(x=df['Time'], y=df['impliedApy'], mode='lines', name='Implied APY', yaxis='y2'))

    # Layout settings
    fig.update_layout(
        title=f'{symbol} on {network} <br />|Long Yield APY V.S. Implied APY|<br />|é•¿æœŸæ”¶ç›Šç‡APYä¸éšå«APY|<br />|é•·æœŸåç›Šç‡APYå¯¾æš—é»™ã®APY|',
        xaxis_title='Certain Time of Purchasing YT',
        yaxis=dict(
            title='Long Yield APY',
            side='left',
        ),
        yaxis2=dict(
            title='Implied APY',
            overlaying='y',
            side='right',
        ),
        template=mode
    )

    # Add vertical line and annotation for the purchase time if provided
    if yt_purchase_time:
        yt_purchase_time_dt = datetime.strptime(yt_purchase_time, '%Y-%m-%d %H:%M:%S')

        fig.add_vline(x=yt_purchase_time_dt, line_width=3, line_dash="dash", line_color="green")

        fig.add_annotation(
            x=yt_purchase_time_dt,
            y=max(df['long_yield_apy']),
            text="YT Purchase Time",
            showarrow=True,
            arrowhead=1,
            ax=20,
            ay=-30
        )

    # Display the plot
    fig.show()

# Example of using the function
plot_yield_vs_implied_apy(df, symbol, network, mode, yt_purchase_time=yt_purchase_time if turn_on_auto_analysis_1 else None)

# @title | Weighted Points (by Volume) Over Time |<br />| éšæ—¶é—´å˜åŒ–çš„åŠ æƒç§¯åˆ†(æŒ‰äº¤æ˜“é‡) |<br />| æ™‚é–“çµŒéã¨ã¨ã‚‚ã«åŠ é‡ãƒã‚¤ãƒ³ãƒˆ |
import plotly.graph_objects as go
from datetime import datetime

def plot_weighted_points_over_time(df, symbol, network, mode, yt_purchase_time=None):
    """Plots Weighted Points (by Volume) Over Time with optional annotations for YT purchase time."""

    # Initialize the figure
    fig = go.Figure(data=go.Scatter(x=df['Time'], y=df['weighted_points'], mode='lines', name='Weighted Points'))

    # Layout settings
    fig.update_layout(
        title=f'{symbol} on {network} <br />|Weighted Points (by Volume) Over Time |<br />| éšæ—¶é—´å˜åŒ–çš„åŠ æƒç§¯åˆ†(æŒ‰äº¤æ˜“é‡) |<br />| æ™‚é–“çµŒéã¨ã¨ã‚‚ã«åŠ é‡ãƒã‚¤ãƒ³ãƒˆ|',
        xaxis_title='Time',
        yaxis_title='Weighted Points',
        template=mode
    )

    # Add vertical line and annotation for the purchase time if provided
    if yt_purchase_time:
        yt_purchase_time_dt = datetime.strptime(yt_purchase_time, '%Y-%m-%d %H:%M:%S')

        fig.add_vline(x=yt_purchase_time_dt, line_width=3, line_dash="dash", line_color="green")

        fig.add_annotation(
            x=yt_purchase_time_dt,
            y=max(df['weighted_points']),
            text="YT Purchase Time",
            showarrow=True,
            arrowhead=1,
            ax=20,
            ay=-30
        )

    # Display the plot
    fig.show()

# Example of using the function
plot_weighted_points_over_time(df, symbol, network, mode, yt_purchase_time=yt_purchase_time if turn_on_auto_analysis_1 else None)

# @title è°ƒæ§åˆ†å¸ƒå›¾çš„æŸ±å­æ•°é‡ï¼Œè¶Šå¤šçš„æŸ±å­ï¼Œå›¾å½¢æ›´å¹³æ»‘ï¼Œä½†æ˜¯ä¹Ÿæ›´ç¦»æ•£|Control the number of columns in the distribution chart. The more columns there are, the smoother the graph will be, but it will also be more discrete.
nbins = 300 # @param {type:"integer"}

# @title | Distribution of Hours per Points Interval Before Weighting |<br />| åœ¨åŠ æƒä¹‹å‰æ¯ç‚¹æ—¶é—´é—´éš”çš„åˆ†å¸ƒ |<br />| åŠ é‡å‰ã®æ™‚é–“ã”ã¨ã®ãƒã‚¤ãƒ³ãƒˆé–“éš”ã®åˆ†å¸ƒ |
import plotly.graph_objects as go

def plot_distribution_of_hours_per_points(df, symbol, network, mode, nbins, points_for_auto_analysis_perunderlying=None):
    """Plots the distribution of hours per points interval before weighting with optional annotations."""

    # Initialize the figure
    fig = go.Figure(data=go.Histogram(x=df['points'], nbinsx=nbins))

    # Layout settings
    fig.update_layout(
        title=f'{symbol} on {network} <br />|Distribution of Hours per Points Interval Before Weighting|<br />|åœ¨åŠ æƒä¹‹å‰æ¯ç‚¹æ—¶é—´é—´éš”çš„åˆ†å¸ƒ|<br />|åŠ é‡å‰ã®æ™‚é–“ã”ã¨ã®ãƒã‚¤ãƒ³ãƒˆé–“éš”ã®åˆ†å¸ƒ|',
        xaxis_title='Points',
        yaxis_title='Number of Hours',
        template=mode
    )

    # Add vertical line and annotation for points for auto analysis if provided
    if points_for_auto_analysis_perunderlying:
        fig.add_vline(x=points_for_auto_analysis_perunderlying, line_width=5, line_dash="dash", line_color="green")

        fig.add_annotation(
            x=points_for_auto_analysis_perunderlying,
            y=10,  # Adjust this value based on your data range
            text="You are here",
            showarrow=True,
            arrowhead=1,
            ax=20,
            ay=-30
        )

    # Display the plot
    fig.show()

# Example of using the function
plot_distribution_of_hours_per_points(df, symbol, network, mode, nbins,
                                      points_for_auto_analysis_perunderlying=points_for_auto_analysis_per_underlying if turn_on_auto_analysis_1 else None)

# @title | Distribution of Hours per Points Interval After Volume Weighting |<br />| åœ¨åŠ æƒä¹‹åæ¯ç‚¹æ—¶é—´é—´éš”çš„åˆ†å¸ƒ |<br />| åŠ é‡å¾Œã®æ™‚é–“ã”ã¨ã®ãƒã‚¤ãƒ³ãƒˆé–“éš”ã®åˆ†å¸ƒ |
import plotly.graph_objects as go

def plot_distribution_of_weighted_points(df, symbol, network, mode, nbins):
    """Plots the distribution of hours per points interval after volume weighting."""

    # Create the histogram for weighted points
    fig = go.Figure(data=go.Histogram(x=df['weighted_points'], nbinsx=nbins))

    # Update layout with titles and axis labels
    fig.update_layout(
        title=f'{symbol} on {network} <br />|Distribution of Hours per Points Interval After Volume Weighting|<br />|åœ¨åŠ æƒä¹‹åæ¯ç‚¹æ—¶é—´é—´éš”çš„åˆ†å¸ƒ|<br />|åŠ é‡å¾Œã®æ™‚é–“ã”ã¨ã®ãƒã‚¤ãƒ³ãƒˆé–“éš”ã®åˆ†å¸ƒ|',
        xaxis_title='Weighted Points',
        yaxis_title='Number of Hours',
        template=mode
    )

    # Display the plot
    fig.show()

# Example of using the function
plot_distribution_of_weighted_points(df, symbol, network, mode, nbins)

# @title MAX&MIN
print(f"å¯¹äºå•æ¬¡æŠ•å…¥ {underlying_amount} underlyingï¼Œåœ¨ Pendle ä¸Šè·å¾—çš„ç§¯åˆ†çš„æ•°é‡èŒƒå›´æ˜¯ï¼šæœ€å°‘ {df['points'].min():.2f} åˆ†ï¼Œæœ€å¤š {df['points'].max():.2f} åˆ†")
print(f"For a single investment of {underlying_amount} underlying on Pendle, the range of points earned is: minimum {df['points'].min():.2f} points, maximum {df['points'].max():.2f} points")

# @title AVERAGE
print(f"æŒ‰äº¤æ˜“é‡åŠ æƒï¼Œå¹³å‡æ¥çœ‹ï¼ŒæŠ•èµ„{underlying_amount} underlyingè·å¾—çš„ç§¯åˆ†æ•°é‡ä¸ºï¼š{weighted_points_per_underlying:.2f}")
print(f"The number of points earned by investing {underlying_amount} underlying, weighted by transaction volume, is: {weighted_points_per_underlying:.2f}")